// I was lazy
// Most of this file is generated by DeepSeek

#include <string_view>
#include <vector>
#include <set>
#include <string>
#include <cctype>
#include <stack>
#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>

struct Method
{
	std::string_view namespaze;
	std::string_view klass;
	std::string_view ret_type;
	std::string_view name;
	std::vector<std::string_view> params;
	bool is_static;
	bool is_icall;
	bool is_class_gen;
};

static std::vector<Method> parse(std::string_view input_file)
{
	std::vector<Method> result;

	size_t pos = 0;
	std::string_view current_namespace;
	std::string_view current_class;
	std::stack<char> brace_stack;
	bool in_valid_class = false;
	bool in_valid_namespace = false;
	bool is_class_gen = false;

	while (pos < input_file.size())
	{
		// Skip whitespace
		while (pos < input_file.size() && std::isspace(input_file[pos]))
		{
			pos++;
		}

		if (pos >= input_file.size())
			break;

		// skip single line comment
		if (pos + 2 <= input_file.size() && input_file.substr(pos, 2) == "//")
		{
			pos += 2;

			while (pos < input_file.size() && input_file[pos] != '\n')
				pos++;

			continue;
		}

		// skip multi line comment
		if (pos + 2 <= input_file.size() && input_file.substr(pos, 2) == "/*")
		{
			pos += 2;

			while (pos + 2 <= input_file.size() && input_file.substr(pos, 2) == "*/")
				pos++;

			continue;
		}

		// Check for namespace
		if (pos + 10 <= input_file.size() && input_file.substr(pos, 10) == "namespace ")
		{
			pos += 10; // Skip "namespace "

			// Find namespace name
			size_t start = pos;
			while (pos < input_file.size() && input_file[pos] != '{' && !std::isspace(input_file[pos]))
			{
				pos++;
			}
			std::string_view namespace_name = input_file.substr(start, pos - start);

			// Find opening brace
			while (pos < input_file.size() && input_file[pos] != '{')
			{
				pos++;
			}

			if (pos < input_file.size())
			{
				brace_stack.push('{');
				current_namespace = namespace_name;
				in_valid_namespace = true;
				pos++; // Skip '{'
			}
			continue;
		}

		bool found_class = false;

		// Check for class definition (but only if we're in a namespace)
		if (in_valid_namespace)
		{
			if (pos + 6 <= input_file.size() && input_file.substr(pos, 6) == "class ")
			{
				pos += 6;
				found_class = true;
			}
			else
			if (pos + 7 <= input_file.size() && input_file.substr(pos, 7) == "struct ")
			{
				pos += 7;
				found_class = true;
			}
		}

		if (found_class)
		{
			// Skip any whitespace after class
			while (pos < input_file.size() && std::isspace(input_file[pos]))
			{
				pos++;
			}

			if (pos + 10 <= input_file.size() && input_file.substr(pos, 10) == "__autogen ")
			{
				pos += 10;
				is_class_gen = true;

				// Skip any whitespace after __autogen
				while (pos < input_file.size() && std::isspace(input_file[pos]))
				{
					pos++;
				}
			}

			// Find class name (stop at '{' or whitespace)
			size_t start = pos;
			while (pos < input_file.size() && input_file[pos] != '{' &&
				input_file[pos] != ';' && !std::isspace(input_file[pos]))
			{
				pos++;
			}

			if (pos >= input_file.size()) continue;

			std::string_view struct_name = input_file.substr(start, pos - start);

			// Find opening brace
			while (pos < input_file.size() && input_file[pos] != '{')
			{
				// Check if it's a forward declaration (struct X;)
				if (input_file[pos] == ';')
				{
					// It's a forward declaration, skip this struct
					pos++;
					break;
				}
				pos++;
			}

			if (pos < input_file.size() && input_file[pos] == '{')
			{
				brace_stack.push('{');
				current_class = struct_name;
				in_valid_class = true;
				pos++; // Skip '{'
			}
			continue;
		}

		bool found_autogen = false;
		bool found_autogen_icall = false;

		if (in_valid_class && in_valid_namespace)
		{
			if (pos + 10 <= input_file.size() && input_file.substr(pos, 10) == "__autogen ")
			{
				found_autogen = true;
				pos += 10;
			}
			else
			if (pos + 16 <= input_file.size() && input_file.substr(pos, 16) == "__autogen_icall ")
			{
				found_autogen_icall = true;
				pos += 16;
			}
		}

		if (found_autogen || found_autogen_icall)
		{
			// Skip whitespace after __autogen
			while (pos < input_file.size() && std::isspace(input_file[pos]))
			{
				pos++;
			}

			// Check for static keyword
			bool is_static = false;
			if (input_file.substr(pos, 7) == "static ")
			{
				is_static = true;
				pos += 7; // Skip "static "

				// Skip whitespace after static
				while (pos < input_file.size() && std::isspace(input_file[pos]))
				{
					pos++;
				}
			}

			// Find return type
			size_t ret_start = pos;
			while (pos < input_file.size() && !std::isspace(input_file[pos]) &&
				input_file[pos] != '(')
			{
				pos++;
			}
			std::string_view ret_type = input_file.substr(ret_start, pos - ret_start);

			// Skip whitespace
			while (pos < input_file.size() && std::isspace(input_file[pos]))
			{
				pos++;
			}

			// Find method name
			size_t name_start = pos;
			while (pos < input_file.size() && input_file[pos] != '(' &&
				!std::isspace(input_file[pos]))
			{
				pos++;
			}
			std::string_view method_name = input_file.substr(name_start, pos - name_start);

			// Find opening parenthesis
			while (pos < input_file.size() && input_file[pos] != '(')
			{
				pos++;
			}
			if (pos >= input_file.size()) continue;

			pos++; // Skip '('

			// Parse parameters
			std::vector<std::string_view> params;
			while (pos < input_file.size() && input_file[pos] != ')')
			{
				// Skip whitespace
				while (pos < input_file.size() && std::isspace(input_file[pos]))
				{
					pos++;
				}

				if (input_file[pos] == ')') break;

				// Skip parameter name if present (we only want the type)
				size_t param_start = pos;

				// Find the parameter type (everything up to a space or comma or closing paren)
				while (pos < input_file.size() && input_file[pos] != ',' &&
					input_file[pos] != ')' && !std::isspace(input_file[pos]))
				{
					pos++;
				}

				std::string_view param = input_file.substr(param_start, pos - param_start);
				if (!param.empty())
				{
					params.push_back(param);
				}

				// Skip to next parameter or closing parenthesis
				while (pos < input_file.size() && input_file[pos] != ',' &&
					input_file[pos] != ')')
				{
					pos++;
				}

				if (input_file[pos] == ',')
				{
					pos++; // Skip ','
				}
			}

			if (pos < input_file.size()) pos++; // Skip ')'

			// Skip to semicolon
			while (pos < input_file.size() && input_file[pos] != ';')
			{
				pos++;
			}
			if (pos < input_file.size()) pos++; // Skip ';'

			// Add to result
			if (!current_namespace.empty() && !current_class.empty() &&
				!ret_type.empty() && !method_name.empty())
			{
				result.emplace_back(
					current_namespace,
					current_class,
					ret_type,
					method_name,
					std::move(params),
					is_static,
					found_autogen_icall,
					is_class_gen
				);
			}

			continue;
		}

		// Handle closing braces
		if (input_file[pos] == '}')
		{
			if (!brace_stack.empty())
			{
				brace_stack.pop();

				// If we close a class brace
				if (in_valid_class)
				{
					in_valid_class = false;
					current_class = std::string_view();
				}
				// If we close a namespace brace
				else if (in_valid_namespace)
				{
					in_valid_namespace = false;
					current_namespace = std::string_view();
					current_class = std::string_view();
				}
			}
			pos++;
			continue;
		}

		// Skip other content
		pos++;
	}

	return result;
}

static std::string replaceAll(std::string str, const std::string_view& from, const std::string_view& to)
{
	if (from.empty())
		return str;

	size_t start_pos = 0;
	while((start_pos = str.find(from, start_pos)) != std::string::npos)
	{
		str.replace(start_pos, from.length(), to);
		start_pos += to.length();
	}

	return str;
}

static std::string replaceArray(std::string type, bool add_array = true)
{
	constexpr auto arr_start = std::string_view("il2cpp.Array<");
	constexpr auto arr_cs = std::string_view("[]");

	if (type.starts_with(arr_start))
	{
		type.erase(type.begin(), type.begin() + arr_start.size());
		type.erase(type.end() - 1);

		if (add_array)
			type.insert(type.end(), arr_cs.begin(), arr_cs.end());

		type = replaceArray(std::move(type));
	}

	return type;
}

static std::string normalize_type(std::string type, bool add_array = true)
{
	auto replaced_scope = replaceAll(std::move(type), "::", ".");
	auto removed_pointers = replaceAll(std::move(replaced_scope), "*", "");
	auto replaced_array = replaceArray(std::move(removed_pointers), add_array);

	return replaced_array;
}

int main(int argc, char* argv[])
{
	// Check command line arguments
	if (argc != 3)
	{
		std::cerr << "Usage: " << argv[0] << " <input_file> <output_file>\n";
		return 1;
	}

	std::string input_path = argv[1];
	std::string output_path = argv[2];

	std::string file_content;

	{
		std::stringstream buffer;

		{
			std::ifstream input_file(input_path);

			if (!input_file.is_open())
			{
				std::cerr << "Error: Cannot open input file: " << input_path << "\n";
				return 1;
			}

			// Read entire file into a string
			buffer << input_file.rdbuf();
		}

		file_content = std::move(buffer).str();
	}

	auto methods = parse(file_content);

	std::ofstream output_file(output_path);

	if (!output_file.is_open())
	{
		std::cerr << "Error: Cannot open output file: " << output_path << "\n";
		return 1;
	}

	output_file << "// Auto generated file - will be overwritten by autogen tool\n";

	if (methods.empty())
		return 0;

	output_file << "#include \"System/primitives.hpp\"\n";
	output_file << "#include \"common/CallCached.hpp\"\n";
	output_file << "#include \"il2cpp/il2cpp.hpp\"\n";
	output_file << "#include \"il2cpp/Class.hpp\"\n";
	output_file << "#include \"il2cpp/Method.hpp\"\n";
	output_file << "#include \"il2cpp/ClassFinder.hpp\"\n\n";
	output_file << "#include <cassert>\n\n";

	{
		std::set<std::string> all_types;
		std::set<std::pair<std::string, std::string>> all_class_gens;

		for (const auto& method : methods)
		{
			if (method.is_class_gen)
				all_class_gens.emplace(std::string(method.namespaze), std::string(method.klass));

			all_types.insert(replaceAll(std::string(method.namespaze), "::", ".") + "." + std::string(method.klass));
			all_types.insert(normalize_type(std::string(method.ret_type), false));

			if (method.ret_type.find("il2cpp::Array") != -1)
				all_types.insert("il2cpp.Array");

			for (const auto& param : method.params)
			{
				all_types.insert(replaceAll(normalize_type(std::string(param), false), "&", ""));

				if (param.find("il2cpp::Array") != -1)
					all_types.insert("il2cpp.Array");
			}
		}

		all_types.erase("System.Void");
		all_types.erase("System.Boolean");
		all_types.erase("System.Char");
		all_types.erase("System.Byte");
		all_types.erase("System.SByte");
		all_types.erase("System.Int16");
		all_types.erase("System.UInt16");
		all_types.erase("System.Int32");
		all_types.erase("System.UInt32");
		all_types.erase("System.Int64");
		all_types.erase("System.UInt64");
		all_types.erase("System.IntPtr");
		all_types.erase("System.UIntPtr");
		all_types.erase("System.Single");
		all_types.erase("System.Double");

		for (const auto& type : all_types)
		{
			std::string type_path = replaceAll(type, ".", "/");
			output_file << "#include \"" << type_path << ".hpp\"\n";
		}

		if (!all_types.empty())
			output_file << "\n";

		for (const auto& class_gen : all_class_gens)
		{
			output_file << "template <>\n";
			output_file << "struct il2cpp::FindClassOnce<" << class_gen.first << "::" << class_gen.second << ">\n";
			output_file << "{\n";
			output_file << "\tstatic const Class* Find()\n";
			output_file << "\t{\n";
			output_file << "\t\tauto klass = CallCached<decltype([]() { ";
			output_file << "return il2cpp::Class::Find(\"" << normalize_type(class_gen.first) << "\", \"" << class_gen.second << "\");";
			output_file << " })>();\n";
			output_file << "\t\tassert(klass);\n";
			output_file << "\t\treturn klass;\n";
			output_file << "\t}\n";
			output_file << "};\n\n";
		}
	}

	for (const auto& method : methods)
	{
		output_file << method.ret_type << " ";
		output_file << method.namespaze << "::";
		output_file << method.klass << "::";
		output_file << method.name << "(";

		for (size_t i = 0; i < method.params.size(); ++i)
		{
			output_file << method.params[i] << " a" << i;

			if (i < method.params.size() - 1)
				output_file << ", ";
		}

		output_file << ")\n";

		output_file << "{\n";

		output_file << "\tauto func = ";

		output_file << "CallCached<decltype([]() {\n";

		if (method.is_icall)
		{
			output_file << "\t\tusing func_t = ";
			output_file << method.ret_type << "(*)(";

			if (!method.is_static)
			{
				output_file << "decltype(this)";

				if (!method.params.empty())
					output_file << ", ";
			}

			for (size_t i = 0; i < method.params.size(); ++i)
			{
				output_file << method.params[i];

				if (i < method.params.size() - 1)
					output_file << ", ";
			}

			output_file << ");\n";

			output_file << "\t\treturn (func_t)il2cpp::resolve_icall(";
			output_file << "\"" << method.namespaze << "." << method.klass << "::" << method.name << "\"";
			output_file << ");\n";
		}
		else
		{
			output_file << "\t\tauto klass = il2cpp::FindClassOnce<" << method.namespaze << "::" << method.klass << ">::Find();\n";
			output_file << "\t\tassert(klass);\n";
			output_file << "\t\tauto method = klass->FindMethod(";
			output_file << "\"" << method.name << "\", ";
			output_file << "\"" << normalize_type(std::string(method.ret_type)) << "\", ";

			output_file << "{ ";
			for (size_t i = 0; i < method.params.size(); ++i)
			{
				output_file << "\"" << normalize_type(std::string(method.params[i])) << "\"";

				if (i < method.params.size() - 1)
					output_file << ",";

				output_file << " ";
			}
			output_file << "}, ";

			output_file << "" << (method.is_static ? "true" : "false");

			output_file << ");\n";
			output_file << "\t\tassert(method);\n";
			output_file << "\t\tauto method_ptr = method->template GetMethodPointer<";

			{
				output_file << method.ret_type << "(";

				if (!method.is_static)
				{
					output_file << "decltype(this)";

					if (!method.params.empty())
						output_file << ", ";
				}

				for (size_t i = 0; i < method.params.size(); ++i)
				{
					output_file << method.params[i];

					if (i < method.params.size() - 1)
						output_file << ", ";
				}

				output_file << ")";
			}

			output_file << ">();\n";
			output_file << "\t\tassert(method_ptr);\n";
			output_file << "\t\treturn method_ptr;\n";
		}

		output_file << "\t})>();\n\n";

		output_file << "\treturn func(";

		if (!method.is_static)
		{
			output_file << "this";

			if (!method.params.empty())
				output_file << ", ";
		}

		for (size_t i = 0; i < method.params.size(); ++i)
		{
			output_file << "a" << i;

			if (i < method.params.size() - 1)
				output_file << ", ";
		}

		output_file << ");\n";

		output_file << "}\n\n";
	}

	return 0;
}
