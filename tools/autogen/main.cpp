// I was lazy
// Most of this file is generated by DeepSeek

#include <string_view>
#include <vector>
#include <set>
#include <string>
#include <cctype>
#include <stack>
#include <algorithm>
#include <fstream>
#include <iostream>
#include <sstream>

struct Method
{
	std::string_view ret_type;
	std::string_view name;
	std::vector<std::string_view> params;
	bool is_static;
	bool is_icall;
};

struct AutoGen
{
	std::string_view namespaze;
	std::string_view klass;
	Method method;
};

std::vector<AutoGen> parse(std::string_view input_file)
{
	std::vector<AutoGen> result;

	size_t pos = 0;
	std::string_view current_namespace;
	std::string_view current_class;
	std::stack<char> brace_stack;
	bool in_valid_class = false;
	bool in_valid_namespace = false;

	while (pos < input_file.size())
	{
		// Skip whitespace
		while (pos < input_file.size() && std::isspace(input_file[pos]))
		{
			pos++;
		}

		if (pos >= input_file.size()) break;

		// Check for namespace
		if (input_file.substr(pos, 10) == "namespace ")
		{
			pos += 10; // Skip "namespace "

			// Find namespace name
			size_t start = pos;
			while (pos < input_file.size() && input_file[pos] != '{' && !std::isspace(input_file[pos]))
			{
				pos++;
			}
			std::string_view namespace_name = input_file.substr(start, pos - start);

			// Find opening brace
			while (pos < input_file.size() && input_file[pos] != '{')
			{
				pos++;
			}

			if (pos < input_file.size())
			{
				brace_stack.push('{');
				current_namespace = namespace_name;
				in_valid_namespace = true;
				pos++; // Skip '{'
			}
			continue;
		}

		// Check for class definition (but only if we're in a namespace)
		if (in_valid_namespace && input_file.substr(pos, 6) == "class ")
		{
			pos += 6; // Skip "class "

			// Skip any whitespace after class
			while (pos < input_file.size() && std::isspace(input_file[pos]))
			{
				pos++;
			}

			// Find class name (stop at '{' or whitespace)
			size_t start = pos;
			while (pos < input_file.size() && input_file[pos] != '{' &&
				input_file[pos] != ';' && !std::isspace(input_file[pos]))
			{
				pos++;
			}

			if (pos >= input_file.size()) continue;

			std::string_view struct_name = input_file.substr(start, pos - start);

			// Find opening brace
			while (pos < input_file.size() && input_file[pos] != '{')
			{
				// Check if it's a forward declaration (struct X;)
				if (input_file[pos] == ';')
				{
					// It's a forward declaration, skip this struct
					pos++;
					break;
				}
				pos++;
			}

			if (pos < input_file.size() && input_file[pos] == '{')
			{
				brace_stack.push('{');
				current_class = struct_name;
				in_valid_class = true;
				pos++; // Skip '{'
			}
			continue;
		}

		bool found_autogen = false;
		bool found_autogen_icall = false;

		if (in_valid_class && in_valid_namespace)
		{
			if (pos + 10 <= input_file.size() && input_file.substr(pos, 10) == "__autogen ")
			{
				found_autogen = true;
				pos += 10;
			}
			else
			if (pos + 16 <= input_file.size() && input_file.substr(pos, 16) == "__autogen_icall ")
			{
				found_autogen_icall = true;
				pos += 16;
			}
		}

		if (found_autogen || found_autogen_icall)
		{
			// Skip whitespace after __autogen
			while (pos < input_file.size() && std::isspace(input_file[pos]))
			{
				pos++;
			}

			// Check for static keyword
			bool is_static = false;
			if (input_file.substr(pos, 7) == "static ")
			{
				is_static = true;
				pos += 7; // Skip "static "

				// Skip whitespace after static
				while (pos < input_file.size() && std::isspace(input_file[pos]))
				{
					pos++;
				}
			}

			// Find return type
			size_t ret_start = pos;
			while (pos < input_file.size() && !std::isspace(input_file[pos]) &&
				input_file[pos] != '(')
			{
				pos++;
			}
			std::string_view ret_type = input_file.substr(ret_start, pos - ret_start);

			// Skip whitespace
			while (pos < input_file.size() && std::isspace(input_file[pos]))
			{
				pos++;
			}

			// Find method name
			size_t name_start = pos;
			while (pos < input_file.size() && input_file[pos] != '(' &&
				!std::isspace(input_file[pos]))
			{
				pos++;
			}
			std::string_view method_name = input_file.substr(name_start, pos - name_start);

			// Find opening parenthesis
			while (pos < input_file.size() && input_file[pos] != '(')
			{
				pos++;
			}
			if (pos >= input_file.size()) continue;

			pos++; // Skip '('

			// Parse parameters
			std::vector<std::string_view> params;
			while (pos < input_file.size() && input_file[pos] != ')')
			{
				// Skip whitespace
				while (pos < input_file.size() && std::isspace(input_file[pos]))
				{
					pos++;
				}

				if (input_file[pos] == ')') break;

				// Skip parameter name if present (we only want the type)
				size_t param_start = pos;

				// Find the parameter type (everything up to a space or comma or closing paren)
				while (pos < input_file.size() && input_file[pos] != ',' &&
					input_file[pos] != ')' && !std::isspace(input_file[pos]))
				{
					pos++;
				}

				std::string_view param = input_file.substr(param_start, pos - param_start);
				if (!param.empty())
				{
					params.push_back(param);
				}

				// Skip to next parameter or closing parenthesis
				while (pos < input_file.size() && input_file[pos] != ',' &&
					input_file[pos] != ')')
				{
					pos++;
				}

				if (input_file[pos] == ',')
				{
					pos++; // Skip ','
				}
			}

			if (pos < input_file.size()) pos++; // Skip ')'

			// Skip to semicolon
			while (pos < input_file.size() && input_file[pos] != ';')
			{
				pos++;
			}
			if (pos < input_file.size()) pos++; // Skip ';'

			// Add to result
			if (!current_namespace.empty() && !current_class.empty() &&
				!ret_type.empty() && !method_name.empty())
			{
				Method method = { ret_type, method_name, params, is_static, found_autogen_icall };
				AutoGen autogen = { current_namespace, current_class, method };
				result.push_back(autogen);
			}

			continue;
		}

		// Handle closing braces
		if (input_file[pos] == '}')
		{
			if (!brace_stack.empty())
			{
				brace_stack.pop();

				// If we close a class brace
				if (in_valid_class)
				{
					in_valid_class = false;
					current_class = std::string_view();
				}
				// If we close a namespace brace
				else if (in_valid_namespace)
				{
					in_valid_namespace = false;
					current_namespace = std::string_view();
					current_class = std::string_view();
				}
			}
			pos++;
			continue;
		}

		// Skip other content
		pos++;
	}

	return result;
}

std::string replaceAll(std::string str, const std::string_view& from, const std::string_view& to)
{
	if (from.empty())
		return str;

	size_t start_pos = 0;
	while((start_pos = str.find(from, start_pos)) != std::string::npos)
	{
		str.replace(start_pos, from.length(), to);
		start_pos += to.length();
	}

	return str;
}

int main(int argc, char* argv[])
{
	// Check command line arguments
	if (argc != 3)
	{
		std::cerr << "Usage: " << argv[0] << " <input_file> <output_file>\n";
		return 1;
	}

	std::string input_path = argv[1];
	std::string output_path = argv[2];

	std::string file_content;

	{
		std::stringstream buffer;

		{
			std::ifstream input_file(input_path);

			if (!input_file.is_open())
			{
				std::cerr << "Error: Cannot open input file: " << input_path << "\n";
				return 1;
			}

			// Read entire file into a string
			buffer << input_file.rdbuf();
		}

		file_content = std::move(buffer).str();
	}

	std::vector<AutoGen> autogen_methods = parse(file_content);

	std::ofstream output_file(output_path);

	if (!output_file.is_open())
	{
		std::cerr << "Error: Cannot open output file: " << output_path << "\n";
		return 1;
	}

	output_file << "// Auto generated file - will be overwritten by autogen tool\n";

	if (autogen_methods.empty())
		return 0;

	{
		std::set<std::string> all_types;

		for (const auto& autogen : autogen_methods)
		{
			all_types.insert(std::string(autogen.namespaze) + "::" + std::string(autogen.klass));
			all_types.insert(replaceAll(std::string(autogen.method.ret_type), "*", ""));

			for (const auto& param : autogen.method.params)
				all_types.insert(replaceAll(std::string(param), "*", ""));
		}

		all_types.erase("System::Void");
		all_types.erase("System::Boolean");
		all_types.erase("System::Char");
		all_types.erase("System::Byte");
		all_types.erase("System::SByte");
		all_types.erase("System::Int16");
		all_types.erase("System::UInt16");
		all_types.erase("System::Int32");
		all_types.erase("System::UInt32");
		all_types.erase("System::Int64");
		all_types.erase("System::UInt64");
		all_types.erase("System::IntPtr");
		all_types.erase("System::UIntPtr");
		all_types.erase("System::Single");
		all_types.erase("System::Double");

		for (const auto& type : all_types)
		{
			std::string type_path = replaceAll(type, "::", "/");
			output_file << "#include \"" << type_path << ".hpp\"\n";
		}

		if (!all_types.empty())
			output_file << "\n";
	}

	output_file << "#include \"System/primitives.hpp\"\n";
	output_file << "#include \"il2cpp/MethodFinder.hpp\"\n\n";

	for (const auto& autogen : autogen_methods)
	{
		output_file << autogen.method.ret_type << " ";
		output_file << autogen.namespaze << "::";
		output_file << autogen.klass << "::";
		output_file << autogen.method.name << "(";

		for (size_t i = 0; i < autogen.method.params.size(); ++i)
		{
			output_file << autogen.method.params[i] << " a" << i;

			if (i < autogen.method.params.size() - 1)
				output_file << ", ";
		}

		output_file << ")\n";

		output_file << "{\n";

		output_file << "\tauto func = ";
		
		if (autogen.method.is_icall)
			output_file << "il2cpp::FindICallMethodOnce<";
		else
			output_file << "il2cpp::FindMethodOnce<";

		output_file << autogen.method.ret_type << "(";

		if (!autogen.method.is_static)
		{
			output_file << "decltype(this)";

			if (!autogen.method.params.empty())
				output_file << ", ";
		}

		for (size_t i = 0; i < autogen.method.params.size(); ++i)
		{
			output_file << autogen.method.params[i];

			if (i < autogen.method.params.size() - 1)
				output_file << ", ";
		}

		output_file << ")>([]() { ";

		if (autogen.method.is_icall)
		{
			output_file << "return il2cpp::resolve_icall(";
			output_file << "\"" << autogen.namespaze << "." << autogen.klass << "::" << autogen.method.name << "\"";
			output_file << ");";
		}
		else
		{
			output_file << "return il2cpp::Method::Find(";
			output_file << "\"" << autogen.namespaze << "\", ";
			output_file << "\"" << autogen.klass << "\", ";
			output_file << "\"" << autogen.method.name << "\", ";
			output_file << "\"" << replaceAll(replaceAll(std::string(autogen.method.ret_type), "::", "."), "*", "") << "\", ";

			output_file << "{ ";
			for (size_t i = 0; i < autogen.method.params.size(); ++i)
			{
				output_file << "\"" << replaceAll(replaceAll(std::string(autogen.method.params[i]), "::", "."), "*", "") << "\"";

				if (i < autogen.method.params.size() - 1)
					output_file << ",";

				output_file << " ";
			}
			output_file << "}, ";

			output_file << "" << (autogen.method.is_static ? "true" : "false");

			output_file << ");";
		}

		output_file << " });\n";

		output_file << "\treturn func(";

		if (!autogen.method.is_static)
		{
			output_file << "this";

			if (!autogen.method.params.empty())
				output_file << ", ";
		}

		for (size_t i = 0; i < autogen.method.params.size(); ++i)
		{
			output_file << "a" << i;

			if (i < autogen.method.params.size() - 1)
				output_file << ", ";
		}

		output_file << ");\n";

		output_file << "}\n\n";
	}

	return 0;
}
